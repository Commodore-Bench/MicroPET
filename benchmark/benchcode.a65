
VIA	=$e840
T2L	=VIA + 8
T2H	=VIA + 9
ACR	=VIA + 11

; define for including fast code check, undefine for slow only
; address of code in fast memory
FAST	=$021000


	*=$290		; tape buffer #1

	; ----------------------------------------------------------------
	; result
benchmark	.word 0

	; jump table
	jmp copy2fast
	jmp benchslow
	jmp benchfast

	; ----------------------------------------------------------------
	; actual code

	; copy the system into fast RAM and switch to it
copy2fast .(
	sei
	
	; native mode
	clc
	xce
	; index 16bit
	rep #%00010000
	.xl
	
	; copy 64k from $00xxxx (system memory) to $F0xxxx (fast RAM bank 0 mirror) 
	.(
	ldx #0
l1
	lda $0000,x
	sta $F00000,x
	inx
	bne l1 
e
	.)
	.xs
	; emulation mode
	sec
	xce
	; then switch original system off
	lda #%00000101
	sta $ebbf
	cli
	rts
	.)


benchslow .(
	// execute a loop in slow memory 
	// time both loop executions and store the result in $2000-$2003

	// shows if stray writes also happen to the VIA timer registers

	sei
	; native mode
	clc
	xce

start	
	lda ACR
	and #%11011111
	sta ACR
	
	lda #0
	sta T2L
	sta T2H

	; delay loop to check
	ldx #0
#ifdef VIDEOBENCH
	ldy #$08	; this halfs the loop, removes
#else
	ldy #$10
#endif
l1 	
#ifdef VIDEOBENCH
	inc $804f	; last character in first line (80 cols) or second line (40 cols)
			; add 6 cycles per iteration, three of them on screen
#endif
	dex
	bne l1
	dey
	bne l1
	lda T2L
	ldx T2H
	sta benchmark
	stx benchmark+1

	jmp @end
end
	; emulation mode
	.xs
	sec
	xce
	cli
	rts

&benchfast 

	len = end - start

	sei
	; native mode
	clc
	xce
	
	; copy over the loop from "start" to "end" to fast RAM
	ldx #len-1
l2	lda start,x
	sta @FAST,x
	dex
	bpl l2

	; execute fast loop
	jmp @FAST
	.)


